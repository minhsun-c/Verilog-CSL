$date
	Thu Oct 12 16:44:00 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb $end
$var wire 16 ! product [15:0] $end
$var reg 8 " A [7:0] $end
$var reg 8 # B [7:0] $end
$var reg 1 $ areset $end
$var reg 1 % clk $end
$scope module M $end
$var wire 1 $ areset $end
$var wire 1 % clk $end
$var wire 8 & multiplicand [7:0] $end
$var wire 8 ' multiplier [7:0] $end
$var wire 8 ( tempSum [7:0] $end
$var wire 2 ) next_state [1:0] $end
$var wire 1 * Cout $end
$var reg 8 + B [7:0] $end
$var reg 16 , product [15:0] $end
$var reg 2 - state [1:0] $end
$scope module ALU $end
$var wire 8 . A [7:0] $end
$var wire 8 / B [7:0] $end
$var wire 1 0 Cin $end
$var wire 7 1 ctemp [7:1] $end
$var wire 8 2 Sum [7:0] $end
$var wire 1 * Cout $end
$scope module F0 $end
$var wire 1 3 A $end
$var wire 1 4 B $end
$var wire 1 0 Cin $end
$var wire 1 5 Cout $end
$var wire 1 6 Sum $end
$upscope $end
$scope module F1 $end
$var wire 1 7 A $end
$var wire 1 8 B $end
$var wire 1 9 Cin $end
$var wire 1 : Cout $end
$var wire 1 ; Sum $end
$upscope $end
$scope module F2 $end
$var wire 1 < A $end
$var wire 1 = B $end
$var wire 1 > Cin $end
$var wire 1 ? Cout $end
$var wire 1 @ Sum $end
$upscope $end
$scope module F3 $end
$var wire 1 A A $end
$var wire 1 B B $end
$var wire 1 C Cin $end
$var wire 1 D Cout $end
$var wire 1 E Sum $end
$upscope $end
$scope module F4 $end
$var wire 1 F A $end
$var wire 1 G B $end
$var wire 1 H Cin $end
$var wire 1 I Cout $end
$var wire 1 J Sum $end
$upscope $end
$scope module F5 $end
$var wire 1 K A $end
$var wire 1 L B $end
$var wire 1 M Cin $end
$var wire 1 N Cout $end
$var wire 1 O Sum $end
$upscope $end
$scope module F6 $end
$var wire 1 P A $end
$var wire 1 Q B $end
$var wire 1 R Cin $end
$var wire 1 S Cout $end
$var wire 1 T Sum $end
$upscope $end
$scope module F7 $end
$var wire 1 U A $end
$var wire 1 V B $end
$var wire 1 W Cin $end
$var wire 1 * Cout $end
$var wire 1 X Sum $end
$upscope $end
$upscope $end
$scope module ControlUnit $end
$var wire 1 $ areset $end
$var wire 1 % clk $end
$var wire 8 Y multiplier [7:0] $end
$var reg 4 Z counter [3:0] $end
$var reg 2 [ state [1:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx [
bx Z
bx Y
xX
xW
xV
xU
xT
xS
xR
xQ
xP
xO
xN
xM
xL
xK
xJ
xI
xH
xG
xF
xE
xD
xC
xB
xA
x@
x?
x>
x=
x<
x;
x:
x9
x8
x7
x6
x5
x4
x3
bx 2
bx 1
00
bx /
bx .
bx -
bx ,
bx +
x*
bx )
bx (
bx '
bx &
0%
x$
bx #
bx "
bx !
$end
#5
14
18
1=
0B
1G
1L
0Q
0V
b0 Z
b0 )
b0 [
1%
b1100100 #
b1100100 '
b110111 "
b110111 &
b110111 /
1$
#10
0E
0C
0T
0?
0R
0N
1@
0>
1O
0:
0M
0I
1;
09
1J
0X
05
0H
0W
b110111 (
b110111 2
16
0D
b0 1
0S
0*
03
07
0<
0A
0F
0K
0P
0U
b0 .
b0 !
b0 ,
b1100100 +
b1100100 Y
b0 -
0$
1%
#15
b1 Z
b10 )
b10 [
1%
#20
b10 Z
b110010 +
b110010 Y
b10 -
1%
#25
b11 Z
b1 )
b1 [
b11001 +
b11001 Y
1%
#30
1H
1D
1T
1C
1R
1?
1N
0@
0O
19
1>
1M
15
1:
b111111 1
1I
06
1;
0E
b1010010 (
b1010010 2
1J
13
17
1A
1F
b11011 .
b100 Z
b10 )
b10 [
b1100 +
b1100 Y
b1101110000000 !
b1101110000000 ,
b1 -
1%
#35
0;
1@
b1000100 (
b1000100 2
0J
07
1<
0F
b1101 .
b101 Z
b110 +
b110 Y
b110111000000 !
b110111000000 ,
b10 -
1%
#40
0T
0R
0N
1O
0M
0I
09
1J
05
0H
16
0;
b110 1
0D
b111101 (
b111101 2
1E
03
17
0A
b110 .
b110 Z
b1 )
b1 [
b11 +
b11 Y
b11011100000 !
b11011100000 ,
1%
#45
1T
1R
1N
0O
1M
1H
1I
b111110 1
1D
0E
b1010101 (
b1010101 2
1J
1A
1F
b11110 .
b111 Z
b1 +
b1 Y
b1111011110000 !
b1111011110000 ,
b1 -
1%
#50
0@
0J
b1100001 (
b1100001 2
1O
0<
0F
1K
b101010 .
b1000 Z
b10 )
b10 [
b0 +
b0 Y
b10101011111000 !
b10101011111000 ,
1%
#55
19
1>
15
1:
0H
06
0;
1@
b110111 1
0D
1E
0J
b1001100 (
b1001100 2
0O
13
07
1<
0A
1F
0K
b10101 .
b11 )
b11 [
b1010101111100 !
b1010101111100 ,
b10 -
1%
#60
b11 -
1%
#65
1%
#70
1J
0C
0?
0>
0R
0:
0N
1;
1O
0*
09
0M
05
0I
16
1@
0H
0W
0D
b0 1
0S
03
0<
0F
1E
1T
b11111111 (
b11111111 2
1X
b0 .
b0 !
b0 ,
b11111111 +
b11111111 Y
1B
1Q
1V
b0 Z
b0 )
b0 [
b11111111 #
b11111111 '
b11111111 "
b11111111 &
b11111111 /
1$
1%
#75
b1 Z
b1 )
b1 [
b0 -
0$
1%
#80
1*
0X
19
1>
1C
1H
1M
1R
1W
15
1:
1?
1D
1I
1N
b1111111 1
1S
06
1;
1@
1E
1J
1O
b1111110 (
b1111110 2
1T
13
17
1<
1A
1F
1K
1P
b1111111 .
b10 Z
b1111111 +
b1111111 Y
b111111110000000 !
b111111110000000 ,
b1 -
1%
#85
0T
b10111110 (
b10111110 2
1X
0P
1U
b10111111 .
b11 Z
b111111 +
b111111 Y
b1011111101000000 !
b1011111101000000 ,
1%
#90
0O
b11011110 (
b11011110 2
1T
0K
1P
b11011111 .
b100 Z
b11111 +
b11111 Y
b1101111100100000 !
b1101111100100000 ,
1%
#95
0J
b11101110 (
b11101110 2
1O
0F
1K
b11101111 .
b101 Z
b1111 +
b1111 Y
b1110111100010000 !
b1110111100010000 ,
1%
#100
0E
b11110110 (
b11110110 2
1J
0A
1F
b11110111 .
b110 Z
b111 +
b111 Y
b1111011100001000 !
b1111011100001000 ,
1%
#105
0@
b11111010 (
b11111010 2
1E
0<
1A
b11111011 .
b111 Z
b11 +
b11 Y
b1111101100000100 !
b1111101100000100 ,
1%
#110
0;
b11111100 (
b11111100 2
1@
07
1<
b11111101 .
b1000 Z
b1 +
b1 Y
b1111110100000010 !
b1111110100000010 ,
1%
#115
09
b1111110 1
05
16
b11111101 (
b11111101 2
0;
03
17
b11111110 .
b11 )
b11 [
b0 +
b0 Y
b1111111000000001 !
b1111111000000001 ,
1%
#120
b11 -
1%
#125
1%
#130
1%
#135
0C
0H
0M
0R
0W
0?
0D
0I
0N
0S
0*
0>
b0 1
0:
07
0<
0A
0F
0K
0P
0U
0;
0@
0E
0J
0O
0T
b1 (
b1 2
0X
b0 .
b0 !
b0 ,
b1 +
b1 Y
08
0=
0B
0G
0L
0Q
0V
b0 Z
b0 )
b0 [
b1 #
b1 '
b1 "
b1 &
b1 /
1$
1%
#140
b1 Z
b1 )
b1 [
b0 -
0$
1%
#145
b10 Z
b10 )
b10 [
b0 +
b0 Y
b10000000 !
b10000000 ,
b1 -
1%
#150
b11 Z
b1000000 !
b1000000 ,
b10 -
1%
#155
b100 Z
b100000 !
b100000 ,
1%
#160
b101 Z
b10000 !
b10000 ,
1%
#165
b110 Z
b1000 !
b1000 ,
1%
#170
b111 Z
b100 !
b100 ,
1%
#175
b1000 Z
b10 !
b10 ,
1%
#180
b11 )
b11 [
b1 !
b1 ,
1%
#185
b11 -
1%
#190
1%
#195
1%
#200
b0 !
b0 ,
b0 Z
b0 )
b0 [
b0 #
b0 '
1$
1%
#205
b1 Z
b10 )
b10 [
b0 -
0$
1%
#210
b10 Z
b10 -
1%
#215
b11 Z
1%
#220
b100 Z
1%
#225
b101 Z
1%
#230
b110 Z
1%
#235
b111 Z
1%
#240
b1000 Z
1%
#245
b11 )
b11 [
1%
#250
b11 -
1%
#255
1%
#260
1%
