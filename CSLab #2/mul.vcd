$date
	Mon Oct  9 23:20:37 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb $end
$var wire 16 ! product [15:0] $end
$var reg 8 " A [7:0] $end
$var reg 8 # B [7:0] $end
$var reg 1 $ areset $end
$var reg 1 % clk $end
$scope module M $end
$var wire 1 $ areset $end
$var wire 1 % clk $end
$var wire 8 & multiplicand [7:0] $end
$var wire 8 ' multiplier [7:0] $end
$var wire 8 ( tempSum [7:0] $end
$var wire 2 ) next_state [1:0] $end
$var wire 1 * Cout $end
$var reg 8 + B [7:0] $end
$var reg 16 , product [15:0] $end
$var reg 2 - state [1:0] $end
$scope module ALU $end
$var wire 8 . A [7:0] $end
$var wire 8 / B [7:0] $end
$var wire 1 0 Cin $end
$var wire 7 1 ctemp [7:1] $end
$var wire 8 2 Sum [7:0] $end
$var wire 1 * Cout $end
$scope module F0 $end
$var wire 1 3 A $end
$var wire 1 4 B $end
$var wire 1 0 Cin $end
$var wire 1 5 Cout $end
$var wire 1 6 Sum $end
$upscope $end
$scope module F1 $end
$var wire 1 7 A $end
$var wire 1 8 B $end
$var wire 1 9 Cin $end
$var wire 1 : Cout $end
$var wire 1 ; Sum $end
$upscope $end
$scope module F2 $end
$var wire 1 < A $end
$var wire 1 = B $end
$var wire 1 > Cin $end
$var wire 1 ? Cout $end
$var wire 1 @ Sum $end
$upscope $end
$scope module F3 $end
$var wire 1 A A $end
$var wire 1 B B $end
$var wire 1 C Cin $end
$var wire 1 D Cout $end
$var wire 1 E Sum $end
$upscope $end
$scope module F4 $end
$var wire 1 F A $end
$var wire 1 G B $end
$var wire 1 H Cin $end
$var wire 1 I Cout $end
$var wire 1 J Sum $end
$upscope $end
$scope module F5 $end
$var wire 1 K A $end
$var wire 1 L B $end
$var wire 1 M Cin $end
$var wire 1 N Cout $end
$var wire 1 O Sum $end
$upscope $end
$scope module F6 $end
$var wire 1 P A $end
$var wire 1 Q B $end
$var wire 1 R Cin $end
$var wire 1 S Cout $end
$var wire 1 T Sum $end
$upscope $end
$scope module F7 $end
$var wire 1 U A $end
$var wire 1 V B $end
$var wire 1 W Cin $end
$var wire 1 * Cout $end
$var wire 1 X Sum $end
$upscope $end
$upscope $end
$scope module ControlUnit $end
$var wire 1 $ areset $end
$var wire 1 % clk $end
$var wire 8 Y multiplier [7:0] $end
$var reg 4 Z counter [3:0] $end
$var reg 2 [ state [1:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx [
bx Z
bx Y
xX
xW
xV
xU
xT
xS
xR
xQ
xP
xO
xN
xM
xL
xK
xJ
xI
xH
xG
xF
xE
xD
xC
xB
xA
x@
x?
x>
x=
x<
x;
x:
x9
x8
x7
x6
x5
x4
x3
bx 2
bx 1
00
bx /
bx .
bx -
bx ,
bx +
x*
bx )
bx (
bx '
bx &
0%
x$
bx #
bx "
bx !
$end
#5
b0 -
14
18
1=
1B
1G
1L
1Q
1V
b0 Z
b0 )
b0 [
1%
b10 #
b10 '
b11111111 "
b11111111 &
b11111111 /
1$
#10
0*
1X
0W
0S
1T
0R
0N
1O
0M
0I
1J
0H
0D
1E
0C
0?
1@
0>
0:
1;
09
b0 1
05
b11111111 (
b11111111 2
16
03
07
0<
0A
0F
0K
0P
0U
b0 .
b0 !
b0 ,
b10 +
b10 Y
0$
1%
#15
b1 Z
b10 )
b10 [
1%
#20
b10 Z
b10 -
1%
#25
b11 Z
b1 )
b1 [
b1 +
b1 Y
1%
#30
b100 Z
b10 )
b10 [
b1 -
b0 +
b0 Y
1%
#35
1*
0X
19
1>
1C
1H
1M
1R
1W
15
1:
1?
1D
1I
1N
b1111111 1
1S
06
1;
1@
1E
1J
1O
b1111110 (
b1111110 2
1T
13
17
1<
1A
1F
1K
1P
b1111111 .
b101 Z
b10 -
b111111110000000 !
b111111110000000 ,
1%
#40
b111110 (
b111110 2
0T
0P
b111111 .
b110 Z
b11111111000000 !
b11111111000000 ,
1%
#45
b11110 (
b11110 2
0O
0K
b11111 .
b111 Z
b1111111100000 !
b1111111100000 ,
1%
#50
b1110 (
b1110 2
0J
0F
b1111 .
b1000 Z
b111111110000 !
b111111110000 ,
1%
#55
b110 (
b110 2
0E
0A
b111 .
b1001 Z
b11111111000 !
b11111111000 ,
1%
#60
b10 (
b10 2
0@
0<
b11 .
b11 )
b11 [
b1111111100 !
b1111111100 ,
1%
#65
b0 (
b0 2
0;
07
b1 .
b11 -
b111111110 !
b111111110 ,
1%
